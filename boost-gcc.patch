--- boost/wave/util/flex_string.hpp.org	2009-06-28 12:32:01.558558136 +0200
+++ boost/wave/util/flex_string.hpp	2009-06-28 12:33:15.595357079 +0200
@@ -1646,7 +1646,6 @@
 #ifndef NDEBUG
         Invariant checker(*this); 
 #endif
-        static std::less_equal<const value_type*> le;
         if (le(&*begin(), s) && le(s, &*end())) // aliasing
         {
             const size_type offset = s - &*begin();
@@ -1795,7 +1794,7 @@
         InputIterator b, InputIterator e, Selector<0>)
     { 
         InsertImpl(i, b, e, 
-            std::iterator_traits<InputIterator>::iterator_category());
+            typename std::iterator_traits<InputIterator>::iterator_category());
         return *this;
     }
 
@@ -1965,7 +1964,7 @@
         InputIterator b, InputIterator e, Selector<0>)
     { 
         ReplaceImpl(i1, i2, b, e, 
-            std::iterator_traits<InputIterator>::iterator_category());
+            typename std::iterator_traits<InputIterator>::iterator_category());
         return *this;
     }
 
commit 35202ddc3df7dfa6195aa08ad718b1bd94528e93
Author: johnmaddock <johnmaddock@b8fc166d-592f-0410-95f2-cb63ce0dd405>
Date:   Fri May 22 16:14:12 2009 +0000

    Add some casts to try and fix gcc-4.4 compiler errors.
    
    git-svn-id: http://svn.boost.org/svn/boost/trunk@53177 b8fc166d-592f-0410-95f2-cb63ce0dd405

diff --git libs/math/test/test_ellint_2.cpp libs/math/test/test_ellint_2.cpp
index 360b009..c348f5a 100644
--- libs/math/test/test_ellint_2.cpp
+++ libs/math/test/test_ellint_2.cpp
@@ -155,8 +155,8 @@ void test_spots(T, const char* type_name)
         SC_(1e-05), SC_(800) / 1024, SC_(9.999999999898274739584436515967055859383969942432E-6),
         SC_(1e+05), SC_(100) / 1024, SC_(99761.153306972066658135668386691227343323331995888),
         SC_(1e+10), SC_(-0.5), SC_(9.3421545766487137036576748555295222252286528414669e9),
-        ldexp(SC_(1), 66), SC_(400) / 1024, SC_(7.0886102721911705466476846969992069994308167515242e19),
-        ldexp(SC_(1), 166), SC_(900) / 1024, SC_(7.1259011068364515942912094521783688927118026465790e49),
+        SC_(ldexp(SC_(1), 66)), SC_(400) / 1024, SC_(7.0886102721911705466476846969992069994308167515242e19),
+        SC_(ldexp(SC_(1), 166)), SC_(900) / 1024, SC_(7.1259011068364515942912094521783688927118026465790e49),
     };
     #undef SC_
 
commit 13e63fbaeaa1bca02ce031736d1b802c021f3f0b
Author: hkaiser <hkaiser@b8fc166d-592f-0410-95f2-cb63ce0dd405>
Date:   Tue Apr 28 02:07:06 2009 +0000

    Spirit: Karma examples now compile using gcc 4.4
    
    git-svn-id: http://svn.boost.org/svn/boost/trunk@52645 b8fc166d-592f-0410-95f2-cb63ce0dd405

diff --git libs/spirit/example/karma/calc2_ast.hpp libs/spirit/example/karma/calc2_ast.hpp
index d3a09cd..435f25a 100644
--- libs/spirit/example/karma/calc2_ast.hpp
+++ libs/spirit/example/karma/calc2_ast.hpp
@@ -18,7 +18,7 @@
 #if !defined(SPIRIT_EXAMPLE_CALC2_AST_APR_30_2008_1011AM)
 #define SPIRIT_EXAMPLE_CALC2_AST_APR_30_2008_1011AM
 
-#include <boost/variant/recursive_variant.hpp>
+#include <boost/variant.hpp>
 #include <boost/spirit/include/phoenix_operator.hpp>
 #include <boost/spirit/include/phoenix_function.hpp>
 #include <boost/spirit/include/phoenix_statement.hpp>

--- boost/proto/expr.hpp~	2008-12-15 18:23:56.000000000 +0100
+++ boost/proto/expr.hpp	2009-06-28 12:41:17.364677514 +0200
@@ -444,7 +444,8 @@
     #undef ARG_COUNT
     #undef IS_TERMINAL
 
-#elif BOOST_PP_ITERATION_DEPTH() == 2
+#else
+#if BOOST_PP_ITERATION_DEPTH() == 2
 
     #define N BOOST_PP_ITERATION()
 
@@ -484,3 +485,4 @@
 
 #endif // BOOST_PP_ITERATION_DEPTH()
 #endif
+#endif
diff --git boost/python/call.hpp boost/python/call.hpp
index 9a3d974..5d2d7d2 100644
--- boost/python/call.hpp
+++ boost/python/call.hpp
@@ -38,7 +38,10 @@ namespace boost { namespace python {
 
 # endif // CALL_DWA2002411_HPP
 
-#elif BOOST_PP_ITERATION_DEPTH() == 1
+// For gcc 4.4 compatability, we must include the
+// BOOST_PP_ITERATION_DEPTH test inside an #else clause.
+#else // BOOST_PP_IS_ITERATING
+#if BOOST_PP_ITERATION_DEPTH() == 1
 # if !(BOOST_WORKAROUND(__MWERKS__, > 0x3100)                      \
         && BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3201)))
 #  line BOOST_PP_LINE(__LINE__, call.hpp)
@@ -76,4 +79,5 @@ call(PyObject* callable
 
 # undef N
 
+#endif // BOOST_PP_ITERATION_DEPTH()
 #endif
diff --git boost/python/call_method.hpp boost/python/call_method.hpp
index 0bca061..410f668 100644
--- boost/python/call_method.hpp
+++ boost/python/call_method.hpp
@@ -37,7 +37,10 @@ namespace boost { namespace python {
 
 # endif // CALL_METHOD_DWA2002411_HPP
 
-#elif BOOST_PP_ITERATION_DEPTH() == 1
+// For gcc 4.4 compatability, we must include the
+// BOOST_PP_ITERATION_DEPTH test inside an #else clause.
+#else // BOOST_PP_IS_ITERATING
+#if BOOST_PP_ITERATION_DEPTH() == 1
 # if !(BOOST_WORKAROUND(__MWERKS__, > 0x3100)                      \
         && BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3201)))
 #  line BOOST_PP_LINE(__LINE__, call_method.hpp)
@@ -76,4 +79,5 @@ call_method(PyObject* self, char const* name
 
 # undef N
 
+#endif // BOOST_PP_ITERATION_DEPTH()
 #endif // BOOST_PP_IS_ITERATING
diff --git boost/python/detail/result.hpp boost/python/detail/result.hpp
index 80e4387..9b8b486 100644
--- boost/python/detail/result.hpp
+++ boost/python/detail/result.hpp
@@ -86,7 +86,10 @@ result(X const&, short = 0) { return 0; }
 # endif // RESULT_DWA2002521_HPP
 
 /* --------------- function pointers --------------- */
-#elif BOOST_PP_ITERATION_DEPTH() == 1 && BOOST_PP_ITERATION_FLAGS() == BOOST_PYTHON_FUNCTION_POINTER
+// For gcc 4.4 compatability, we must include the
+// BOOST_PP_ITERATION_DEPTH test inside an #else clause.
+#else // BOOST_PP_IS_ITERATING
+#if BOOST_PP_ITERATION_DEPTH() == 1 && BOOST_PP_ITERATION_FLAGS() == BOOST_PYTHON_FUNCTION_POINTER
 # if !(BOOST_WORKAROUND(__MWERKS__, > 0x3100)                      \
         && BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3201)))
 #  line BOOST_PP_LINE(__LINE__, result.hpp(function pointers))
@@ -128,4 +131,5 @@ boost::type<R>* result(R (T::*)(BOOST_PP_ENUM_PARAMS_Z(1, N, A)) Q, int = 0)
 # undef N
 # undef Q
 
+#endif // BOOST_PP_ITERATION_DEPTH()
 #endif
diff --git boost/python/detail/target.hpp boost/python/detail/target.hpp
index 5079699..137801b 100644
--- boost/python/detail/target.hpp
+++ boost/python/detail/target.hpp
@@ -37,7 +37,10 @@ T& (* target(R (T::*)) )() { return 0; }
 # endif // TARGET_DWA2002521_HPP
 
 /* --------------- function pointers --------------- */
-#elif BOOST_PP_ITERATION_DEPTH() == 1 && BOOST_PP_ITERATION_FLAGS() == BOOST_PYTHON_FUNCTION_POINTER
+// For gcc 4.4 compatability, we must include the
+// BOOST_PP_ITERATION_DEPTH test inside an #else clause.
+#else // BOOST_PP_IS_ITERATING
+#if BOOST_PP_ITERATION_DEPTH() == 1 && BOOST_PP_ITERATION_FLAGS() == BOOST_PYTHON_FUNCTION_POINTER
 # if !(BOOST_WORKAROUND(__MWERKS__, > 0x3100)                      \
         && BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3201)))
 #  line BOOST_PP_LINE(__LINE__, target.hpp(function_pointers))
@@ -79,4 +82,5 @@ T& (* target(R (T::*)(BOOST_PP_ENUM_PARAMS_Z(1, N, A)) Q) )()
 # undef N
 # undef Q
 
+#endif // BOOST_PP_ITERATION_DEPTH()
 #endif
diff --git boost/python/object/make_holder.hpp boost/python/object/make_holder.hpp
index 9d5de98..eb3c603 100644
--- boost/python/object/make_holder.hpp
+++ boost/python/object/make_holder.hpp
@@ -47,7 +47,10 @@ template <int nargs> struct make_holder;
 
 # endif // MAKE_HOLDER_DWA20011215_HPP
 
-#elif BOOST_PP_ITERATION_DEPTH() == 1
+// For gcc 4.4 compatability, we must include the
+// BOOST_PP_ITERATION_DEPTH test inside an #else clause.
+#else // BOOST_PP_IS_ITERATING
+#if BOOST_PP_ITERATION_DEPTH() == 1
 # if !(BOOST_WORKAROUND(__MWERKS__, > 0x3100)                      \
         && BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3201)))
 #  line BOOST_PP_LINE(__LINE__, make_holder.hpp)
@@ -102,4 +105,5 @@ struct make_holder<N>
 
 # undef N
 
+#endif // BOOST_PP_ITERATION_DEPTH()
 #endif
diff --git boost/python/object/pointer_holder.hpp boost/python/object/pointer_holder.hpp
index 9019a18..2dc6dda 100644
--- boost/python/object/pointer_holder.hpp
+++ boost/python/object/pointer_holder.hpp
@@ -170,7 +170,10 @@ void* pointer_holder_back_reference<Pointer, Value>::holds(type_info dst_t, bool
 # endif // POINTER_HOLDER_DWA20011215_HPP
 
 /* --------------- pointer_holder --------------- */
-#elif BOOST_PP_ITERATION_DEPTH() == 1 && BOOST_PP_ITERATION_FLAGS() == 1
+// For gcc 4.4 compatability, we must include the
+// BOOST_PP_ITERATION_DEPTH test inside an #else clause.
+#else // BOOST_PP_IS_ITERATING
+#if BOOST_PP_ITERATION_DEPTH() == 1 && BOOST_PP_ITERATION_FLAGS() == 1
 # if !(BOOST_WORKAROUND(__MWERKS__, > 0x3100)                      \
         && BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3201)))
 #  line BOOST_PP_LINE(__LINE__, pointer_holder.hpp)
@@ -212,4 +215,5 @@ void* pointer_holder_back_reference<Pointer, Value>::holds(type_info dst_t, bool
 
 # undef N
 
+#endif // BOOST_PP_ITERATION_DEPTH()
 #endif
diff --git boost/python/object/value_holder.hpp boost/python/object/value_holder.hpp
index e53866a..f4d452c 100644
--- boost/python/object/value_holder.hpp
+++ boost/python/object/value_holder.hpp
@@ -117,7 +117,10 @@ void* value_holder_back_reference<Value,Held>::holds(
 
 // --------------- value_holder ---------------
 
-#elif BOOST_PP_ITERATION_DEPTH() == 1 && BOOST_PP_ITERATION_FLAGS() == 1
+// For gcc 4.4 compatability, we must include the
+// BOOST_PP_ITERATION_DEPTH test inside an #else clause.
+#else // BOOST_PP_IS_ITERATING
+#if BOOST_PP_ITERATION_DEPTH() == 1 && BOOST_PP_ITERATION_FLAGS() == 1
 # if !(BOOST_WORKAROUND(__MWERKS__, > 0x3100)                      \
         && BOOST_WORKAROUND(__MWERKS__, BOOST_TESTED_AT(0x3201)))
 #  line BOOST_PP_LINE(__LINE__, value_holder.hpp(value_holder))
@@ -163,4 +166,5 @@ void* value_holder_back_reference<Value,Held>::holds(
 
 # undef N
 
+#endif // BOOST_PP_ITERATION_DEPTH()
 #endif
diff --git boost/python/signature.hpp boost/python/signature.hpp
index c415181..1bb2b22 100644
--- boost/python/signature.hpp
+++ boost/python/signature.hpp
@@ -113,7 +113,10 @@ struct most_derived
 
 # endif // SIGNATURE_JDG20020813_HPP
 
-#elif BOOST_PP_ITERATION_DEPTH() == 1 // defined(BOOST_PP_IS_ITERATING)
+// For gcc 4.4 compatability, we must include the
+// BOOST_PP_ITERATION_DEPTH test inside an #else clause.
+#else // BOOST_PP_IS_ITERATING
+#if BOOST_PP_ITERATION_DEPTH() == 1 // defined(BOOST_PP_IS_ITERATING)
 
 # define N BOOST_PP_ITERATION()
 
@@ -176,4 +179,5 @@ get_signature(
 # undef Q
 # undef N
 
+#endif // BOOST_PP_ITERATION_DEPTH()
 #endif // !defined(BOOST_PP_IS_ITERATING)
